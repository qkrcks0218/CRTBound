hat.gamma.S[tt] <- max(0,min(1,hat.TNT.S[tt]/(hat.TCO.S[tt]+hat.TNT.S[tt])))
hat.lambda1.S[tt] <- max(0,min(1,(hat.S1.S[tt] - hat.T1NT.S[tt])/(hat.TAT.S[tt]+hat.TCO.S[tt])))
hat.delta.S[tt] <- max(0,min(1,hat.TAT.S[tt]/(hat.TAT.S[tt]+hat.TCO.S[tt])))
hat.NT.B.S[tt,] <- c(max(0,hat.T1NT.S[tt]/hat.TNT.S[tt] - hat.pi0.S[tt]/hat.gamma.S[tt]),
min(hat.T1NT.S[tt]/hat.TNT.S[tt],hat.T1NT.S[tt]/hat.TNT.S[tt] + (-hat.pi0.S[tt]+(1-hat.gamma.S[tt]))/hat.gamma.S[tt]))
hat.AT.B.S[tt,] <- c(max(0,(hat.lambda1.S[tt]-1+hat.delta.S[tt])/hat.delta.S[tt]-hat.T0AT.S[tt]/hat.TAT.S[tt]),
min(1-hat.T0AT.S[tt]/hat.TAT.S[tt],hat.lambda1.S[tt]/hat.delta.S[tt]-hat.T0AT.S[tt]/hat.TAT.S[tt]))
hat.CO.B.S[tt,] <- c(max(0,(hat.lambda1.S[tt]-hat.delta.S[tt])/(1-hat.delta.S[tt])-hat.pi0.S[tt]/(1-hat.gamma.S[tt])),
min(1,hat.lambda1.S[tt]/(1-hat.delta.S[tt])+(-hat.pi0.S[tt]+hat.gamma.S[tt])/(1-hat.gamma.S[tt])))
hat.NT.B.S[tt,is.nan(hat.NT.B.S[tt,])] <- 0
hat.AT.B.S[tt,is.nan(hat.AT.B.S[tt,])] <- 0
hat.CO.B.S[tt,is.nan(hat.CO.B.S[tt,])] <- 0
}
hat.TNT.S[is.nan(hat.TNT.S)] <- 0
hat.TAT.S[is.nan(hat.TAT.S)] <- 0
hat.TCO.S[is.nan(hat.TCO.S)] <- 0
hat.NT.B.A <- apply(matrix(hat.TNT.S/sum(hat.TNT.S),length(Strata.Var.lv),2)*hat.NT.B.S,2,sum)
hat.AT.B.A <- apply(matrix(hat.TAT.S/sum(hat.TAT.S),length(Strata.Var.lv),2)*hat.AT.B.S,2,sum)
hat.CO.B.A <- apply(matrix(hat.TCO.S/sum(hat.TCO.S),length(Strata.Var.lv),2)*hat.CO.B.S,2,sum)
}
if(CIcalc==TRUE){
S.estimates <- matrix(0,SSsize,6)
S.estimates.A <- matrix(0,SSsize,6)
for(ss in 1:SSsize){
set.seed(seed+ss)
sA <- 0
while(sA<=1){
selected.1 <- sample(which(Zc==1),m,replace = TRUE)
selected.0 <- sample(which(Zc==0),J-m,replace = TRUE)
S.J <- J
S.m <- length(selected.1)
Zselected.1 <- which(C==Class[selected.1[1]])
Zselected.0 <- which(C==Class[selected.0[1]])
for(ii in 2:length(selected.1)){
Zselected.1 <- c(Zselected.1,which(C==Class[selected.1[ii]]))
}
for(ii in 2:length(selected.0)){
Zselected.0 <- c(Zselected.0,which(C==Class[selected.0[ii]]))
}
S.Y <- Y[c(Zselected.1,Zselected.0)]
S.A <- A[c(Zselected.1,Zselected.0)]
S.N <- length(c(Zselected.1,Zselected.0))
S.nc <- nc[c(selected.1,selected.0)]
S.Jind <- rep(1:S.J,S.nc)
S.m <- length(selected.1)
S.Zc <- c(rep(1, length(selected.1)),rep(0, length(selected.0)))
S.Z <- rep(0,S.N)
S.Z[ 1:length(Zselected.1) ] <- 1
S.X <- X[c(Zselected.1,Zselected.0),]
S.C <- rep(1:S.J,S.nc)
S.Class <- 1:S.J
sA <- min(sum(S.A[S.Z==0]),sum((1-S.A)[S.Z==1]))
}
################ Estimation
S.p1 <- S.m/S.J ; S.p0 <- (S.J-S.m)/S.J
bY <- bNT <- bAT <- rep(0,S.J)
bT1NT <- bT0AT <- rep(0,S.J)
for(jj in 1:S.J){
if(S.Zc[jj]==1){
bY[jj] <- sum(S.Y[S.C==S.Class[jj]])/sum(S.nc[S.Zc==1])
bNT[jj] <- sum((1-S.A)[S.C==S.Class[jj]])/sum(S.nc[S.Zc==1])
bT1NT[jj] <- sum((S.Y*(1-S.A))[S.C==S.Class[jj]])/sum(S.nc[S.Zc==1])
} else {
bY[jj] <- sum(S.Y[S.C==S.Class[jj]])/sum(S.nc[S.Zc==0])
bAT[jj] <- sum(S.A[S.C==S.Class[jj]])/sum(S.nc[S.Zc==0])
bT0AT[jj] <- sum((S.Y*S.A)[S.C==S.Class[jj]])/sum(S.nc[S.Zc==0])
}
}
S.hat.S1 <- sum(bY*S.Zc)*S.N
S.hat.S0 <- sum(bY*(1-S.Zc))*S.N
S.hat.TNT <- sum(bNT*S.Zc)*S.N
S.hat.TAT <- sum(bAT*(1-S.Zc))*S.N
S.hat.TCO <- max(S.N - S.hat.TNT - S.hat.TAT,0)
S.hat.T1NT <- sum(bT1NT*S.Zc)*S.N
S.hat.T0AT <- sum(bT0AT*(1-S.Zc))*S.N
S.hat.pi0 <- max(0,min(1,(S.hat.S0 - S.hat.T0AT)/(S.hat.TCO+S.hat.TNT)))
S.hat.gamma <- max(0,min(1,(S.hat.TNT)/(S.hat.TCO+S.hat.TNT)))
S.hat.lambda1 <- max(0,min(1,(S.hat.S1 - S.hat.T1NT)/(S.hat.TAT+S.hat.TCO)))
S.hat.delta <- max(0,min(1,(S.hat.TAT)/(S.hat.TAT+S.hat.TCO)))
S.hat.NT.B <- c(max(0,S.hat.T1NT/S.hat.TNT - S.hat.pi0/S.hat.gamma),
min(S.hat.T1NT/S.hat.TNT,S.hat.T1NT/S.hat.TNT + (-S.hat.pi0+(1-S.hat.gamma))/S.hat.gamma))
S.hat.AT.B <- c(max(0,(S.hat.lambda1-1+S.hat.delta)/S.hat.delta-S.hat.T0AT/S.hat.TAT),
min(1-S.hat.T0AT/S.hat.TAT,S.hat.lambda1/S.hat.delta-S.hat.T0AT/S.hat.TAT))
S.hat.CO.B <- c(max(0,(S.hat.lambda1-S.hat.delta)/(1-S.hat.delta)-S.hat.pi0/(1-S.hat.gamma)),
min(1,S.hat.lambda1/(1-S.hat.delta)+(-S.hat.pi0+S.hat.gamma)/(1-S.hat.gamma)))
S.estimates[ss,] <- c(S.hat.NT.B, S.hat.AT.B, S.hat.CO.B)
if(!is.null(paraC)){
########## Binary variable
S.Strata.Var <- as.matrix( S.X[,paraC] )
S.Strata.Var <- as.numeric( apply(matrix(2^((dim(S.Strata.Var)[2]-1):0),dim(S.Strata.Var)[1],dim(S.Strata.Var)[2],byrow=T)*as.matrix( S.X[,paraC] ),1,sum) )+1
S.Strata.Var.lv <- sort(unique(S.Strata.Var))
S.N.S <- S.hat.S1.S <- S.hat.S0.S <- S.hat.T1NT.S <- S.hat.T1AT.S <- S.hat.T1CO.S <-
S.hat.T0NT.S <- S.hat.T0AT.S <- S.hat.T0CO.S <- S.hat.TNT.S <- S.hat.TAT.S <- S.hat.TCO.S <- rep(0,length(Strata.Var.lv))
S.hat.pi0.S <- S.hat.gamma.S <- S.hat.lambda1.S <- S.hat.delta.S <- rep(0,length(Strata.Var.lv))
S.hat.NT.B.S <- S.hat.AT.B.S <- S.hat.CO.B.S <- matrix(0,length(Strata.Var.lv),2)
for(tt in 1:length(S.Strata.Var.lv)){
S.St <- S.Strata.Var.lv[tt]
S.xx <- as.numeric(S.Strata.Var==S.St)
S.N.S[tt] <- sum(S.xx)
S.bY <- S.bNT <- S.bAT <- rep(0,S.J)
S.bT1NT <- S.bT0AT <- rep(0,S.J)
for(jj in 1:S.J){
if(S.Zc[jj]==1){
if(sum(S.xx[S.Z==1])!=0){
S.bY[jj] <- sum((S.Y*S.xx)[S.C==S.Class[jj]])/sum(S.xx[S.Z==1])
S.bNT[jj] <- sum(((1-S.A)*S.xx)[S.C==S.Class[jj]])/sum(S.xx[S.Z==1])
S.bT1NT[jj] <- sum((S.Y*(1-S.A)*S.xx)[S.C==S.Class[jj]])/sum(S.xx[S.Z==1])
} else {
S.bY[jj] <- S.bNT[jj] <- S.bT1NT[jj] <- 0
}
} else {
if(sum(S.xx[S.Z==0])!=0){
S.bY[jj] <- sum((S.Y*S.xx)[S.C==S.Class[jj]])/sum(S.xx[S.Z==0])
S.bAT[jj] <- sum((S.A*S.xx)[S.C==S.Class[jj]])/sum(S.xx[S.Z==0])
S.bT0AT[jj] <- sum((S.Y*S.A*S.xx)[S.C==S.Class[jj]])/sum(S.xx[S.Z==0])
} else {
S.bY[jj] <- S.bAT[jj] <- S.bT0AT[jj] <- 0
}
}
}
S.hat.S1.S[tt] <- sum(S.bY*S.Zc)*S.N.S[tt]
S.hat.S0.S[tt] <- sum(S.bY*(1-S.Zc))*S.N.S[tt]
S.hat.TNT.S[tt] <- sum(S.bNT*S.Zc)*S.N.S[tt]
S.hat.TAT.S[tt] <- sum(S.bAT*(1-S.Zc))*S.N.S[tt]
S.hat.TCO.S[tt] <- max( S.N.S[tt] - S.hat.TNT.S[tt] - S.hat.TAT.S[tt], 0)
S.hat.T1NT.S[tt] <- sum(S.bT1NT*S.Zc)*S.N.S[tt]
S.hat.T0AT.S[tt] <- sum(S.bT0AT*(1-S.Zc))*S.N.S[tt]
S.hat.pi0.S[tt] <- max(0,min(1,(S.hat.S0.S[tt] - S.hat.T0AT.S[tt])/(S.hat.TCO.S[tt]+S.hat.TNT.S[tt])))
S.hat.gamma.S[tt] <- max(0,min(1,S.hat.TNT.S[tt]/(S.hat.TCO.S[tt]+S.hat.TNT.S[tt])))
S.hat.lambda1.S[tt] <- max(0,min(1,(S.hat.S1.S[tt] - S.hat.T1NT.S[tt])/(S.hat.TAT.S[tt]+S.hat.TCO.S[tt])))
S.hat.delta.S[tt] <- max(0,min(1,S.hat.TAT.S[tt]/(S.hat.TAT.S[tt]+S.hat.TCO.S[tt])))
S.hat.NT.B.S[tt,] <- c(max(0,S.hat.T1NT.S[tt]/S.hat.TNT.S[tt] - S.hat.pi0.S[tt]/S.hat.gamma.S[tt]),
min(S.hat.T1NT.S[tt]/S.hat.TNT.S[tt],S.hat.T1NT.S[tt]/S.hat.TNT.S[tt] + (-S.hat.pi0.S[tt]+(1-S.hat.gamma.S[tt]))/S.hat.gamma.S[tt]))
S.hat.AT.B.S[tt,] <- c(max(0,(S.hat.lambda1.S[tt]-1+S.hat.delta.S[tt])/S.hat.delta.S[tt]-S.hat.T0AT.S[tt]/S.hat.TAT.S[tt]),
min(1-S.hat.T0AT.S[tt]/S.hat.TAT.S[tt],S.hat.lambda1.S[tt]/S.hat.delta.S[tt]-S.hat.T0AT.S[tt]/S.hat.TAT.S[tt]))
S.hat.CO.B.S[tt,] <- c(max(0,(S.hat.lambda1.S[tt]-S.hat.delta.S[tt])/(1-S.hat.delta.S[tt])-S.hat.pi0.S[tt]/(1-S.hat.gamma.S[tt])),
min(1,S.hat.lambda1.S[tt]/(1-S.hat.delta.S[tt])+(-S.hat.pi0.S[tt]+S.hat.gamma.S[tt])/(1-S.hat.gamma.S[tt])))
S.hat.NT.B.S[tt,is.nan(S.hat.NT.B.S[tt,])] <- 0
S.hat.AT.B.S[tt,is.nan(S.hat.AT.B.S[tt,])] <- 0
S.hat.CO.B.S[tt,is.nan(S.hat.CO.B.S[tt,])] <- 0
}
S.hat.TNT.S[is.nan(S.hat.TNT.S)] <- 0
S.hat.TAT.S[is.nan(S.hat.TAT.S)] <- 0
S.hat.TCO.S[is.nan(S.hat.TCO.S)] <- 0
S.hat.NT.B.A <- apply(matrix(S.hat.TNT.S/sum(S.hat.TNT.S),length(Strata.Var.lv),2)*S.hat.NT.B.S,2,sum)
S.hat.AT.B.A <- apply(matrix(S.hat.TAT.S/sum(S.hat.TAT.S),length(Strata.Var.lv),2)*S.hat.AT.B.S,2,sum)
S.hat.CO.B.A <- apply(matrix(S.hat.TCO.S/sum(S.hat.TCO.S),length(Strata.Var.lv),2)*S.hat.CO.B.S,2,sum)
S.hat.NT.B.A[is.nan(S.hat.NT.B.A)] <- 0
S.hat.AT.B.A[is.nan(S.hat.AT.B.A)] <- 0
S.hat.CO.B.A[is.nan(S.hat.CO.B.A)] <- 0
S.estimates.A[ss,] <- c(S.hat.NT.B.A, S.hat.AT.B.A, S.hat.CO.B.A)
}
}
}
S.estimates <- as.matrix(S.estimates)
if(!is.null(paraC)){
S.estimates.A <- as.matrix(S.estimates.A)
}
Result$Bound.NoAdj <- data.frame(matrix(c(hat.NT.B,hat.AT.B,hat.CO.B)*(maxY-minY)+minY,1,6))
if(!is.null(paraC)){
Result$Bound.Adj <- data.frame(matrix(c(hat.NT.B.A,hat.AT.B.A,hat.CO.B.A)*(maxY-minY)+minY,1,6))
# Result$Para <- cbind( VarType,
#                       hat.TNT.S,hat.TCO.S,hat.TAT.S,
#                       N.S,
#                       N.Z1.S,N.Z0.S)
}
if(CIcalc==TRUE){
Result$Resample.Bound.NoAdj <- S.estimates*(maxY-minY)+minY
Result$BootCIBound.NoAdj <- data.frame(matrix(c( quantile(S.estimates[,1]*(maxY-minY)+minY,alpha/2),
quantile(S.estimates[,2]*(maxY-minY)+minY,1-alpha/2),
quantile(S.estimates[,3]*(maxY-minY)+minY,alpha/2),
quantile(S.estimates[,4]*(maxY-minY)+minY,1-alpha/2),
quantile(S.estimates[,5]*(maxY-minY)+minY,alpha/2),
quantile(S.estimates[,6]*(maxY-minY)+minY,1-alpha/2) ),1,6))
if(!is.null(paraC)){
Result$Resample.Bound.Adj <- S.estimates.A*(maxY-minY)+minY
Result$BootCIBound.Adj <- data.frame(matrix(c( quantile(S.estimates.A[,1]*(maxY-minY)+minY,alpha/2),
quantile(S.estimates.A[,2]*(maxY-minY)+minY,1-alpha/2),
quantile(S.estimates.A[,3]*(maxY-minY)+minY,alpha/2),
quantile(S.estimates.A[,4]*(maxY-minY)+minY,1-alpha/2),
quantile(S.estimates.A[,5]*(maxY-minY)+minY,alpha/2),
quantile(S.estimates.A[,6]*(maxY-minY)+minY,1-alpha/2) ),1,6))
}
colnames(Result$Bound.NoAdj) <-
colnames(Result$Resample.Bound.NoAdj) <-
colnames(Result$BootCIBound.NoAdj) <- c("NT.LB","NT.UB","AT.LB","AT.UB","CO.LB","CO.UB")
if(!is.null(paraC)){
colnames(Result$Bound.Adj) <-
colnames(Result$Resample.Bound.Adj) <-
colnames(Result$BootCIBound.Adj) <- c("NT.LB","NT.UB","AT.LB","AT.UB","CO.LB","CO.UB")
}
}
options(warn = defaultW)
return(Result)
}
LongHudgens(result,paraC=NULL,CIcalc=TRUE,SSsize=100,level=0.95,seed=1)
LongHudgens <- function(result , paraC=NULL, CIcalc=FALSE, SSsize=1000, level=0.95, seed=1){
# result : reformed data
# paraC  : column index of X that are used in sharpening bounds
# CIcalc : none (=0), bootstrap (="Boot")
# Bsize  : number of bootstrap iterations
defaultW <- getOption("warn")
options(warn = -1)
alpha <- 1-level
Result <- list()
maxY <- max(result$Y)
minY <- min(result$Y)
Y <- (result$Y-minY)/(maxY-minY)
Z <- result$Z
C <- result$C
A <- result$A
Class <- result$Class
J <- result$J
N <- result$N
n <- result$n
nc <- result$nc
Zc <- result$Zc
m <- result$m
X <- result$X
if(!is.null(paraC)){
for(jj in 1:length(paraC)){
if(length( unique(X[,paraC[jj]]) )!=2){
print("Chosen Xs must be binary. Use different paraC arguments.")
return()
}
}
}
error <- result$error
################ Estimation
p1 <- m/J ; p0 <- (J-m)/J
bY <- bNT <- bAT <- rep(0,J)
bT1NT <- bT0AT <- rep(0,J)
for(jj in 1:J){
if(Zc[jj]==1){
bY[jj] <- sum(Y[C==Class[jj]])/sum(nc[Zc==1])
bNT[jj] <- sum((1-A)[C==Class[jj]])/sum(nc[Zc==1])
bT1NT[jj] <- sum((Y*(1-A))[C==Class[jj]])/sum(nc[Zc==1])
} else {
bY[jj] <- sum(Y[C==Class[jj]])/sum(nc[Zc==0])
bAT[jj] <- sum(A[C==Class[jj]])/sum(nc[Zc==0])
bT0AT[jj] <- sum((Y*A)[C==Class[jj]])/sum(nc[Zc==0])
}
}
hat.S1 <- sum(bY*Zc)*N
hat.S0 <- sum(bY*(1-Zc))*N
hat.TNT <- sum(bNT*Zc)*N
hat.TAT <- sum(bAT*(1-Zc))*N
hat.TCO <- N - hat.TNT - hat.TAT
hat.T1NT <- sum(bT1NT*Zc)*N
hat.T0AT <- sum(bT0AT*(1-Zc))*N
hat.pi0 <- (hat.S0 - hat.T0AT)/(hat.TCO+hat.TNT)
hat.gamma <- (hat.TNT)/(hat.TCO+hat.TNT)
hat.lambda1 <- (hat.S1 - hat.T1NT)/(hat.TAT+hat.TCO)
hat.delta <- (hat.TAT)/(hat.TAT+hat.TCO)
hat.NT.B <- c(max(0,hat.T1NT/hat.TNT - hat.pi0/hat.gamma),min(hat.T1NT/hat.TNT,hat.T1NT/hat.TNT + (-hat.pi0+(1-hat.gamma))/hat.gamma))
hat.AT.B <- c(max(0,(hat.lambda1-1+hat.delta)/hat.delta-hat.T0AT/hat.TAT),min(1-hat.T0AT/hat.TAT,hat.lambda1/hat.delta-hat.T0AT/hat.TAT))
hat.CO.B <- c(max(0,(hat.lambda1-hat.delta)/(1-hat.delta)-hat.pi0/(1-hat.gamma)),min(1,hat.lambda1/(1-hat.delta)+(-hat.pi0+hat.gamma)/(1-hat.gamma)))
########## Binary variable
if(!is.null(paraC)){
Strata.Var <- as.matrix( X[,paraC] )
Strata.Var <- as.numeric( apply(matrix(2^((dim(Strata.Var)[2]-1):0),dim(Strata.Var)[1],dim(Strata.Var)[2],byrow=T)*as.matrix( X[,paraC] ),1,sum) )+1
Strata.Var.lv <- sort(unique(Strata.Var))
VarType <- unique( cbind(Strata.Var,X[,paraC]) )
VarType <- VarType[order(VarType[,1]),]
N.S <- N.Z1.S <- N.Z0.S <- hat.S1.S <- hat.S0.S <- hat.T1NT.S <- hat.T1AT.S <- hat.T1CO.S <-
hat.T0NT.S <- hat.T0AT.S <- hat.T0CO.S <- hat.TNT.S <- hat.TAT.S <- hat.TCO.S <- rep(0,length(Strata.Var.lv))
hat.pi0.S <- hat.gamma.S <- hat.lambda1.S <- hat.delta.S <- rep(0,length(Strata.Var.lv))
hat.NT.B.S <- hat.AT.B.S <- hat.CO.B.S <- matrix(0,length(Strata.Var.lv),2)
for(tt in 1:length(Strata.Var.lv)){
St <- Strata.Var.lv[tt]
xx <- as.numeric(Strata.Var==St)
N.S[tt] <- sum(xx)
N.Z1.S[tt] <- sum(xx*as.numeric(Z==1))
N.Z0.S[tt] <- sum(xx*as.numeric(Z==0))
bY <- bNT <- bAT <- rep(0,J)
bT1NT <- bT0AT <- rep(0,J)
for(jj in 1:J){
if(Zc[jj]==1){
if( sum(xx[Z==1])!=0 ){
bY[jj] <- sum((Y*xx)[C==Class[jj]])/sum(xx[Z==1])
bNT[jj] <- sum(((1-A)*xx)[C==Class[jj]])/sum(xx[Z==1])
bT1NT[jj] <- sum((Y*(1-A)*xx)[C==Class[jj]])/sum(xx[Z==1])
} else {
bY[jj] <- bNT[jj] <- bT1NT[jj] <- 0
}
} else {
if( sum(xx[Z==0])!= 0 ){
bY[jj] <- sum((Y*xx)[C==Class[jj]])/sum(xx[Z==0])
bAT[jj] <- sum((A*xx)[C==Class[jj]])/sum(xx[Z==0])
bT0AT[jj] <- sum((Y*A*xx)[C==Class[jj]])/sum(xx[Z==0])
} else {
bY[jj] <- bAT[jj] <- bT0AT[jj] <- 0
}
}
}
hat.S1.S[tt] <- sum(bY*Zc)*N.S[tt]
hat.S0.S[tt] <- sum(bY*(1-Zc))*N.S[tt]
hat.TNT.S[tt] <- sum(bNT*Zc)*N.S[tt]
hat.TAT.S[tt] <- sum(bAT*(1-Zc))*N.S[tt]
hat.TCO.S[tt] <- max(N.S[tt] - hat.TNT.S[tt] - hat.TAT.S[tt],0)
hat.T1NT.S[tt] <- sum(bT1NT*Zc)*N.S[tt]
hat.T0AT.S[tt] <- sum(bT0AT*(1-Zc))*N.S[tt]
hat.pi0.S[tt] <- max(0,min(1,(hat.S0.S[tt] - hat.T0AT.S[tt])/(hat.TCO.S[tt]+hat.TNT.S[tt])))
hat.gamma.S[tt] <- max(0,min(1,hat.TNT.S[tt]/(hat.TCO.S[tt]+hat.TNT.S[tt])))
hat.lambda1.S[tt] <- max(0,min(1,(hat.S1.S[tt] - hat.T1NT.S[tt])/(hat.TAT.S[tt]+hat.TCO.S[tt])))
hat.delta.S[tt] <- max(0,min(1,hat.TAT.S[tt]/(hat.TAT.S[tt]+hat.TCO.S[tt])))
hat.NT.B.S[tt,] <- c(max(0,hat.T1NT.S[tt]/hat.TNT.S[tt] - hat.pi0.S[tt]/hat.gamma.S[tt]),
min(hat.T1NT.S[tt]/hat.TNT.S[tt],hat.T1NT.S[tt]/hat.TNT.S[tt] + (-hat.pi0.S[tt]+(1-hat.gamma.S[tt]))/hat.gamma.S[tt]))
hat.AT.B.S[tt,] <- c(max(0,(hat.lambda1.S[tt]-1+hat.delta.S[tt])/hat.delta.S[tt]-hat.T0AT.S[tt]/hat.TAT.S[tt]),
min(1-hat.T0AT.S[tt]/hat.TAT.S[tt],hat.lambda1.S[tt]/hat.delta.S[tt]-hat.T0AT.S[tt]/hat.TAT.S[tt]))
hat.CO.B.S[tt,] <- c(max(0,(hat.lambda1.S[tt]-hat.delta.S[tt])/(1-hat.delta.S[tt])-hat.pi0.S[tt]/(1-hat.gamma.S[tt])),
min(1,hat.lambda1.S[tt]/(1-hat.delta.S[tt])+(-hat.pi0.S[tt]+hat.gamma.S[tt])/(1-hat.gamma.S[tt])))
hat.NT.B.S[tt,is.nan(hat.NT.B.S[tt,])] <- 0
hat.AT.B.S[tt,is.nan(hat.AT.B.S[tt,])] <- 0
hat.CO.B.S[tt,is.nan(hat.CO.B.S[tt,])] <- 0
}
hat.TNT.S[is.nan(hat.TNT.S)] <- 0
hat.TAT.S[is.nan(hat.TAT.S)] <- 0
hat.TCO.S[is.nan(hat.TCO.S)] <- 0
hat.NT.B.A <- apply(matrix(hat.TNT.S/sum(hat.TNT.S),length(Strata.Var.lv),2)*hat.NT.B.S,2,sum)
hat.AT.B.A <- apply(matrix(hat.TAT.S/sum(hat.TAT.S),length(Strata.Var.lv),2)*hat.AT.B.S,2,sum)
hat.CO.B.A <- apply(matrix(hat.TCO.S/sum(hat.TCO.S),length(Strata.Var.lv),2)*hat.CO.B.S,2,sum)
}
if(CIcalc==TRUE){
S.estimates <- matrix(0,SSsize,6)
S.estimates.A <- matrix(0,SSsize,6)
for(ss in 1:SSsize){
set.seed(seed+ss)
sA <- 0
while(sA<=1){
selected.1 <- sample(which(Zc==1),m,replace = TRUE)
selected.0 <- sample(which(Zc==0),J-m,replace = TRUE)
S.J <- J
S.m <- length(selected.1)
Zselected.1 <- which(C==Class[selected.1[1]])
Zselected.0 <- which(C==Class[selected.0[1]])
for(ii in 2:length(selected.1)){
Zselected.1 <- c(Zselected.1,which(C==Class[selected.1[ii]]))
}
for(ii in 2:length(selected.0)){
Zselected.0 <- c(Zselected.0,which(C==Class[selected.0[ii]]))
}
S.Y <- Y[c(Zselected.1,Zselected.0)]
S.A <- A[c(Zselected.1,Zselected.0)]
S.N <- length(c(Zselected.1,Zselected.0))
S.nc <- nc[c(selected.1,selected.0)]
S.Jind <- rep(1:S.J,S.nc)
S.m <- length(selected.1)
S.Zc <- c(rep(1, length(selected.1)),rep(0, length(selected.0)))
S.Z <- rep(0,S.N)
S.Z[ 1:length(Zselected.1) ] <- 1
S.X <- X[c(Zselected.1,Zselected.0),]
S.C <- rep(1:S.J,S.nc)
S.Class <- 1:S.J
sA <- min(sum(S.A[S.Z==0]),sum((1-S.A)[S.Z==1]))
}
################ Estimation
S.p1 <- S.m/S.J ; S.p0 <- (S.J-S.m)/S.J
bY <- bNT <- bAT <- rep(0,S.J)
bT1NT <- bT0AT <- rep(0,S.J)
for(jj in 1:S.J){
if(S.Zc[jj]==1){
bY[jj] <- sum(S.Y[S.C==S.Class[jj]])/sum(S.nc[S.Zc==1])
bNT[jj] <- sum((1-S.A)[S.C==S.Class[jj]])/sum(S.nc[S.Zc==1])
bT1NT[jj] <- sum((S.Y*(1-S.A))[S.C==S.Class[jj]])/sum(S.nc[S.Zc==1])
} else {
bY[jj] <- sum(S.Y[S.C==S.Class[jj]])/sum(S.nc[S.Zc==0])
bAT[jj] <- sum(S.A[S.C==S.Class[jj]])/sum(S.nc[S.Zc==0])
bT0AT[jj] <- sum((S.Y*S.A)[S.C==S.Class[jj]])/sum(S.nc[S.Zc==0])
}
}
S.hat.S1 <- sum(bY*S.Zc)*S.N
S.hat.S0 <- sum(bY*(1-S.Zc))*S.N
S.hat.TNT <- sum(bNT*S.Zc)*S.N
S.hat.TAT <- sum(bAT*(1-S.Zc))*S.N
S.hat.TCO <- max(S.N - S.hat.TNT - S.hat.TAT,0)
S.hat.T1NT <- sum(bT1NT*S.Zc)*S.N
S.hat.T0AT <- sum(bT0AT*(1-S.Zc))*S.N
S.hat.pi0 <- max(0,min(1,(S.hat.S0 - S.hat.T0AT)/(S.hat.TCO+S.hat.TNT)))
S.hat.gamma <- max(0,min(1,(S.hat.TNT)/(S.hat.TCO+S.hat.TNT)))
S.hat.lambda1 <- max(0,min(1,(S.hat.S1 - S.hat.T1NT)/(S.hat.TAT+S.hat.TCO)))
S.hat.delta <- max(0,min(1,(S.hat.TAT)/(S.hat.TAT+S.hat.TCO)))
S.hat.NT.B <- c(max(0,S.hat.T1NT/S.hat.TNT - S.hat.pi0/S.hat.gamma),
min(S.hat.T1NT/S.hat.TNT,S.hat.T1NT/S.hat.TNT + (-S.hat.pi0+(1-S.hat.gamma))/S.hat.gamma))
S.hat.AT.B <- c(max(0,(S.hat.lambda1-1+S.hat.delta)/S.hat.delta-S.hat.T0AT/S.hat.TAT),
min(1-S.hat.T0AT/S.hat.TAT,S.hat.lambda1/S.hat.delta-S.hat.T0AT/S.hat.TAT))
S.hat.CO.B <- c(max(0,(S.hat.lambda1-S.hat.delta)/(1-S.hat.delta)-S.hat.pi0/(1-S.hat.gamma)),
min(1,S.hat.lambda1/(1-S.hat.delta)+(-S.hat.pi0+S.hat.gamma)/(1-S.hat.gamma)))
S.estimates[ss,] <- c(S.hat.NT.B, S.hat.AT.B, S.hat.CO.B)
if(!is.null(paraC)){
########## Binary variable
S.Strata.Var <- as.matrix( S.X[,paraC] )
S.Strata.Var <- as.numeric( apply(matrix(2^((dim(S.Strata.Var)[2]-1):0),dim(S.Strata.Var)[1],dim(S.Strata.Var)[2],byrow=T)*as.matrix( S.X[,paraC] ),1,sum) )+1
S.Strata.Var.lv <- sort(unique(S.Strata.Var))
S.N.S <- S.hat.S1.S <- S.hat.S0.S <- S.hat.T1NT.S <- S.hat.T1AT.S <- S.hat.T1CO.S <-
S.hat.T0NT.S <- S.hat.T0AT.S <- S.hat.T0CO.S <- S.hat.TNT.S <- S.hat.TAT.S <- S.hat.TCO.S <- rep(0,length(Strata.Var.lv))
S.hat.pi0.S <- S.hat.gamma.S <- S.hat.lambda1.S <- S.hat.delta.S <- rep(0,length(Strata.Var.lv))
S.hat.NT.B.S <- S.hat.AT.B.S <- S.hat.CO.B.S <- matrix(0,length(Strata.Var.lv),2)
for(tt in 1:length(S.Strata.Var.lv)){
S.St <- S.Strata.Var.lv[tt]
S.xx <- as.numeric(S.Strata.Var==S.St)
S.N.S[tt] <- sum(S.xx)
S.bY <- S.bNT <- S.bAT <- rep(0,S.J)
S.bT1NT <- S.bT0AT <- rep(0,S.J)
for(jj in 1:S.J){
if(S.Zc[jj]==1){
if(sum(S.xx[S.Z==1])!=0){
S.bY[jj] <- sum((S.Y*S.xx)[S.C==S.Class[jj]])/sum(S.xx[S.Z==1])
S.bNT[jj] <- sum(((1-S.A)*S.xx)[S.C==S.Class[jj]])/sum(S.xx[S.Z==1])
S.bT1NT[jj] <- sum((S.Y*(1-S.A)*S.xx)[S.C==S.Class[jj]])/sum(S.xx[S.Z==1])
} else {
S.bY[jj] <- S.bNT[jj] <- S.bT1NT[jj] <- 0
}
} else {
if(sum(S.xx[S.Z==0])!=0){
S.bY[jj] <- sum((S.Y*S.xx)[S.C==S.Class[jj]])/sum(S.xx[S.Z==0])
S.bAT[jj] <- sum((S.A*S.xx)[S.C==S.Class[jj]])/sum(S.xx[S.Z==0])
S.bT0AT[jj] <- sum((S.Y*S.A*S.xx)[S.C==S.Class[jj]])/sum(S.xx[S.Z==0])
} else {
S.bY[jj] <- S.bAT[jj] <- S.bT0AT[jj] <- 0
}
}
}
S.hat.S1.S[tt] <- sum(S.bY*S.Zc)*S.N.S[tt]
S.hat.S0.S[tt] <- sum(S.bY*(1-S.Zc))*S.N.S[tt]
S.hat.TNT.S[tt] <- sum(S.bNT*S.Zc)*S.N.S[tt]
S.hat.TAT.S[tt] <- sum(S.bAT*(1-S.Zc))*S.N.S[tt]
S.hat.TCO.S[tt] <- max( S.N.S[tt] - S.hat.TNT.S[tt] - S.hat.TAT.S[tt], 0)
S.hat.T1NT.S[tt] <- sum(S.bT1NT*S.Zc)*S.N.S[tt]
S.hat.T0AT.S[tt] <- sum(S.bT0AT*(1-S.Zc))*S.N.S[tt]
S.hat.pi0.S[tt] <- max(0,min(1,(S.hat.S0.S[tt] - S.hat.T0AT.S[tt])/(S.hat.TCO.S[tt]+S.hat.TNT.S[tt])))
S.hat.gamma.S[tt] <- max(0,min(1,S.hat.TNT.S[tt]/(S.hat.TCO.S[tt]+S.hat.TNT.S[tt])))
S.hat.lambda1.S[tt] <- max(0,min(1,(S.hat.S1.S[tt] - S.hat.T1NT.S[tt])/(S.hat.TAT.S[tt]+S.hat.TCO.S[tt])))
S.hat.delta.S[tt] <- max(0,min(1,S.hat.TAT.S[tt]/(S.hat.TAT.S[tt]+S.hat.TCO.S[tt])))
S.hat.NT.B.S[tt,] <- c(max(0,S.hat.T1NT.S[tt]/S.hat.TNT.S[tt] - S.hat.pi0.S[tt]/S.hat.gamma.S[tt]),
min(S.hat.T1NT.S[tt]/S.hat.TNT.S[tt],S.hat.T1NT.S[tt]/S.hat.TNT.S[tt] + (-S.hat.pi0.S[tt]+(1-S.hat.gamma.S[tt]))/S.hat.gamma.S[tt]))
S.hat.AT.B.S[tt,] <- c(max(0,(S.hat.lambda1.S[tt]-1+S.hat.delta.S[tt])/S.hat.delta.S[tt]-S.hat.T0AT.S[tt]/S.hat.TAT.S[tt]),
min(1-S.hat.T0AT.S[tt]/S.hat.TAT.S[tt],S.hat.lambda1.S[tt]/S.hat.delta.S[tt]-S.hat.T0AT.S[tt]/S.hat.TAT.S[tt]))
S.hat.CO.B.S[tt,] <- c(max(0,(S.hat.lambda1.S[tt]-S.hat.delta.S[tt])/(1-S.hat.delta.S[tt])-S.hat.pi0.S[tt]/(1-S.hat.gamma.S[tt])),
min(1,S.hat.lambda1.S[tt]/(1-S.hat.delta.S[tt])+(-S.hat.pi0.S[tt]+S.hat.gamma.S[tt])/(1-S.hat.gamma.S[tt])))
S.hat.NT.B.S[tt,is.nan(S.hat.NT.B.S[tt,])] <- 0
S.hat.AT.B.S[tt,is.nan(S.hat.AT.B.S[tt,])] <- 0
S.hat.CO.B.S[tt,is.nan(S.hat.CO.B.S[tt,])] <- 0
}
S.hat.TNT.S[is.nan(S.hat.TNT.S)] <- 0
S.hat.TAT.S[is.nan(S.hat.TAT.S)] <- 0
S.hat.TCO.S[is.nan(S.hat.TCO.S)] <- 0
S.hat.NT.B.A <- apply(matrix(S.hat.TNT.S/sum(S.hat.TNT.S),length(Strata.Var.lv),2)*S.hat.NT.B.S,2,sum)
S.hat.AT.B.A <- apply(matrix(S.hat.TAT.S/sum(S.hat.TAT.S),length(Strata.Var.lv),2)*S.hat.AT.B.S,2,sum)
S.hat.CO.B.A <- apply(matrix(S.hat.TCO.S/sum(S.hat.TCO.S),length(Strata.Var.lv),2)*S.hat.CO.B.S,2,sum)
S.hat.NT.B.A[is.nan(S.hat.NT.B.A)] <- 0
S.hat.AT.B.A[is.nan(S.hat.AT.B.A)] <- 0
S.hat.CO.B.A[is.nan(S.hat.CO.B.A)] <- 0
S.estimates.A[ss,] <- c(S.hat.NT.B.A, S.hat.AT.B.A, S.hat.CO.B.A)
}
}
}
S.estimates <- as.matrix(S.estimates)
if(!is.null(paraC)){
S.estimates.A <- as.matrix(S.estimates.A)
}
Result$Bound.NoAdj <- data.frame(matrix(c(hat.NT.B,hat.AT.B,hat.CO.B)*(maxY-minY)+minY,1,6))
if(!is.null(paraC)){
Result$Bound.Adj <- data.frame(matrix(c(hat.NT.B.A,hat.AT.B.A,hat.CO.B.A)*(maxY-minY)+minY,1,6))
# Result$Para <- cbind( VarType,
#                       hat.TNT.S,hat.TCO.S,hat.TAT.S,
#                       N.S,
#                       N.Z1.S,N.Z0.S)
}
if(CIcalc==TRUE){
Result$Resample.Bound.NoAdj <- S.estimates*(maxY-minY)+minY
Result$BootCIBound.NoAdj <- data.frame(matrix(c( quantile(S.estimates[,1]*(maxY-minY)+minY,alpha/2),
quantile(S.estimates[,2]*(maxY-minY)+minY,1-alpha/2),
quantile(S.estimates[,3]*(maxY-minY)+minY,alpha/2),
quantile(S.estimates[,4]*(maxY-minY)+minY,1-alpha/2),
quantile(S.estimates[,5]*(maxY-minY)+minY,alpha/2),
quantile(S.estimates[,6]*(maxY-minY)+minY,1-alpha/2) ),1,6))
if(!is.null(paraC)){
Result$Resample.Bound.Adj <- S.estimates.A*(maxY-minY)+minY
Result$BootCIBound.Adj <- data.frame(matrix(c( quantile(S.estimates.A[,1]*(maxY-minY)+minY,alpha/2),
quantile(S.estimates.A[,2]*(maxY-minY)+minY,1-alpha/2),
quantile(S.estimates.A[,3]*(maxY-minY)+minY,alpha/2),
quantile(S.estimates.A[,4]*(maxY-minY)+minY,1-alpha/2),
quantile(S.estimates.A[,5]*(maxY-minY)+minY,alpha/2),
quantile(S.estimates.A[,6]*(maxY-minY)+minY,1-alpha/2) ),1,6))
}
colnames(Result$Bound.NoAdj) <-
colnames(Result$Resample.Bound.NoAdj) <-
colnames(Result$BootCIBound.NoAdj) <- c("NT.LB","NT.UB","AT.LB","AT.UB","CO.LB","CO.UB")
if(!is.null(paraC)){
colnames(Result$Bound.Adj) <-
colnames(Result$Resample.Bound.Adj) <-
colnames(Result$BootCIBound.Adj) <- c("NT.LB","NT.UB","AT.LB","AT.UB","CO.LB","CO.UB")
}
}
options(warn = defaultW)
return(Result)
}
LongHudgens(result,paraC=NULL,CIcalc=TRUE,SSsize=100,level=0.95,seed=1)
Bound2 <- LongHudgens(result,paraC=c(3),CIcalc=TRUE,SSsize=100,level=0.95,seed=1)
attributes(Bound2)
Bound3 <- Bound.Intersect(Bound1,Bound2,level=0.95)
attributes(Bound3)
devtools::install_github("qkrcks0218/CRTBound")
library(CRTBound)
library(CRTBound)
?logistic
?solution
?Data.Reform
?ITT
?HTE
?SharpBound
